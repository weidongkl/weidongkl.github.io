"use strict";(self.webpackChunkweidongkl_github_io=self.webpackChunkweidongkl_github_io||[]).push([[1752],{54996:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>d,default:()=>p,frontMatter:()=>o,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"note/os/zombie","title":"Zombie Processes","description":"Orphan process: The father dies first, and the son is adopted by process 1.","source":"@site/i18n/en/docusaurus-plugin-content-docs/current/note/os/zombie.md","sourceDirName":"note/os","slug":"/note/os/zombie","permalink":"/en/docs/note/os/zombie","draft":false,"unlisted":false,"editUrl":"https://github.com/weidongkl/weidongkl.github.io/tree/master/docs/note/os/zombie.md","tags":[],"version":"current","lastUpdatedBy":"weidongkl","lastUpdatedAt":1756560213000,"frontMatter":{},"sidebar":"note","previous":{"title":"Kernel Module Makefile: -y vs -objs","permalink":"/en/docs/note/os/kernel/build_flag"},"next":{"title":"Build","permalink":"/en/docs/category/build"}}');var t=s(74848),r=s(28453);const o={},d="Zombie Processes",c={},l=[{value:"Killing Zombie Processes",id:"killing-zombie-processes",level:2},{value:"Examples",id:"examples",level:2},{value:"Orphan Process",id:"orphan-process",level:3},{value:"Zombie Process",id:"zombie-process",level:3},{value:"Reclaiming the Child",id:"reclaiming-the-child",level:3}];function a(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"zombie-processes",children:"Zombie Processes"})}),"\n",(0,t.jsx)(n.p,{children:"Orphan process: The father dies first, and the son is adopted by process 1."}),"\n",(0,t.jsx)(n.p,{children:"Zombie process: The son dies first, and the father doesn't care."}),"\n",(0,t.jsx)(n.h2,{id:"killing-zombie-processes",children:"Killing Zombie Processes"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["Use ",(0,t.jsx)(n.code,{children:"top"})," to check if there are zombie processes"]}),"\n",(0,t.jsx)(n.li,{children:"Query where the zombie processes are through commands"}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"ps -A -ostat,ppid,pid,cmd | grep -e '^[Zz]'\n# Command explanation:\n\n# -A parameter lists all processes\n\n# -o custom output fields, we set the display fields to stat (status), ppid (parent process id), pid (process id), cmd (command) these four parameters\n\n# Because processes with status z or Z are zombie processes, we use grep to capture processes with stat status zZ\n"})}),"\n",(0,t.jsx)(n.h2,{id:"examples",children:"Examples"}),"\n",(0,t.jsx)(n.h3,{id:"orphan-process",children:"Orphan Process"}),"\n",(0,t.jsxs)(n.p,{children:["By controlling the sleep time, the father dies first, and the son is adopted by the orphanage (process 1). You can check through ",(0,t.jsx)(n.code,{children:"ps"})," that the parent process of ",(0,t.jsx)(n.code,{children:"a.out"})," becomes 1."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-c",children:'#include <stdio.h>  \n#include <stdlib.h>  \n#include <unistd.h>  \n#include <sys/wait.h>  \n  \nint main() {  \n    pid_t pid = fork(); // Create child process  \n  \n    if (pid < 0) {  \n        // fork failed  \n        perror("fork failed");  \n        exit(EXIT_FAILURE);  \n    } else if (pid == 0) {  \n        // Child process  \n        printf("I am the child process with PID %d\\n", getpid());  \n        sleep(2000); // Let the child process run for a while, at this time the father is already dead.\n        printf("Child process exiting...\\n");  \n        exit(EXIT_SUCCESS); // Child process exits  \n    } else {  \n        // Parent process exits directly\n        printf("I am the parent process with PID %d and my child has PID %d\\n", getpid(), pid);  \n    }  \n    return 0;  \n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"zombie-process",children:"Zombie Process"}),"\n",(0,t.jsx)(n.p,{children:"By controlling the sleep time, the child process dies first. However, the parent process does not reclaim the child process."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-c",children:'#include <stdio.h>  \n#include <stdlib.h>  \n#include <unistd.h>  \n#include <sys/wait.h>  \n  \nint main() {  \n    pid_t pid = fork(); // Create child process  \n  \n    if (pid < 0) {  \n        // fork failed  \n        perror("fork failed");  \n        exit(EXIT_FAILURE);  \n    } else if (pid == 0) {  \n        // Child process  \n        printf("I am the child process with PID %d\\n", getpid());  \n        sleep(2); // Let the child process run for a while  \n        printf("Child process exiting...\\n");  \n        exit(EXIT_SUCCESS); // Child process exits  \n    } else {  \n        // Parent process  \n        printf("I am the parent process with PID %d and my child has PID %d\\n", getpid(), pid);  \n        // Note: The parent process does not call wait() or waitpid() here, so the child process will become a zombie process  \n        sleep(10000);  \n    }  \n    return 0;  \n}\n'})}),"\n",(0,t.jsx)(n.p,{children:"Query zombie processes"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"$ ps -A -ostat,ppid,pid,cmd | grep -e '^[Zz]'\nZ+    933981  933982 [a.out] <defunct>\n$ ps -ef | grep a.out\nroot      933981  933844  0 11:11 pts/4    00:00:00 ./a.out\nroot      933982  933981  0 11:11 pts/4    00:00:00 [a.out] <defunct>\nroot      934096  933897  0 11:13 pts/5    00:00:00 grep --color=auto a.out\n"})}),"\n",(0,t.jsx)(n.h3,{id:"reclaiming-the-child",children:"Reclaiming the Child"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-c",children:'#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <signal.h>\n#include <sys/wait.h>\n\n// SIGCHLD signal handler function\nvoid sigchld_handler(int signum) {\n    // Use waitpid non-blocking to reclaim all terminated child processes\n    while (waitpid(-1, NULL, WNOHANG) > 0);\n}\n\nint main() {\n    // Set up SIGCHLD signal handler\n    struct sigaction sa;\n    sa.sa_handler = sigchld_handler;\n    sigemptyset(&sa.sa_mask);\n    sa.sa_flags = SA_RESTART; // Automatically restart interrupted system calls\n    if (sigaction(SIGCHLD, &sa, NULL) == -1) {\n        perror("sigaction");\n        exit(EXIT_FAILURE);\n    }\n\n    // Create child process\n    pid_t pid = fork();\n    if (pid < 0) {\n        perror("fork");\n        exit(EXIT_FAILURE);\n    }\n\n    if (pid == 0) {\n        // Child process\n        printf("Child process: PID = %d\\n", getpid());\n        sleep(10); // Simulate child process executing some tasks\n        printf("Child process ending: PID = %d\\n", getpid());\n        exit(EXIT_SUCCESS);\n    } else {\n        // Parent process\n        printf("Parent process: PID = %d, Child process PID = %d\\n", getpid(), pid);\n        // Parent process continues to execute other tasks\n        for (int i = 0; i < 5; ++i) {\n            printf("Parent process is working...\\n");\n            sleep(10000);\n        }\n        // Cleanup work before parent process ends\n        printf("Parent process ending: PID = %d\\n", getpid());\n    }\n    return 0;\n}\n'})})]})}function p(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(a,{...e})}):a(e)}},28453:(e,n,s)=>{s.d(n,{R:()=>o,x:()=>d});var i=s(96540);const t={},r=i.createContext(t);function o(e){const n=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:o(e.components),i.createElement(r.Provider,{value:n},e.children)}}}]);